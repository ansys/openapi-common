import logging
import os
import warnings
from typing import Tuple, Union, Container, Optional, Mapping, TypeVar

import requests
from urllib3.util.retry import Retry  # type: ignore
from requests.adapters import HTTPAdapter
from requests.auth import HTTPBasicAuth  # type: ignore
from requests_ntlm import HttpNtlmAuth  # type: ignore

from ._api_client import ApiClient
from ._util import (
    parse_authenticate,
    SessionConfiguration,
    set_session_kwargs,
)
from ._exceptions import ApiConnectionException, AuthenticationWarning

logger = logging.getLogger("ansys.openapi.common")

TYPE_CHECKING = False
if TYPE_CHECKING:
    from ._util import CaseInsensitiveOrderedDict

_oidc_enabled = True
_linux_kerberos_enabled = True
_platform_windows = False

try:
    # noinspection PyUnresolvedReferences
    import requests_oauthlib  # type: ignore
    import keyring
    from ._oidc import OIDCSessionFactory
except ImportError:
    _oidc_enabled = False

if os.name == "nt":
    # noinspection PyUnresolvedReferences
    from requests_negotiate_sspi import HttpNegotiateAuth as NegotiateAuth  # type: ignore

    _platform_windows = True
else:
    try:
        # noinspection PyUnresolvedReferences
        from requests_kerberos import HTTPKerberosAuth as NegotiateAuth  # type: ignore

        _linux_kerberos_enabled = True
    except ImportError:
        _linux_kerberos_enabled = False

    _platform_windows = False

# Required to allow the ApiClientFactory to be subclassed. This ensures that Pylance
# understands that the sub-class is returned by the builder methods instead of the base class
Api_Client_Factory = TypeVar("Api_Client_Factory", bound="ApiClientFactory")


class ApiClientFactory:

    _session: requests.Session
    _api_url: str
    _auth_header: "CaseInsensitiveOrderedDict"
    _configured: bool

    def __init__(
        self, api_url: str, session_configuration: SessionConfiguration = None
    ) -> None:
        """Create a factory that configures an API client for use with autogenerated Swagger clients.

        Handles setting up retry strategy, session-level timeout and any additional requests configuration,
        authentication must be subsequently configured using one of the other class methods.

        Parameters
        ----------
        api_url : str
           Base URL of the API server.
        session_configuration : Optional[SessionConfiguration]
           Additional configuration settings for the requests Session.
        """
        self._session = requests.Session()
        self._api_url = api_url
        self._configured = False
        logger.info(f"[TECHDOCS]Creating new session at '{api_url}")

        if session_configuration is None:
            session_configuration = SessionConfiguration()
        self._session_configuration = session_configuration

        logger.debug(
            f"[TECHDOCS]Setting requests session parameter 'max_retries' "
            f"with value '{self._session_configuration.retry_count}'"
        )
        logger.debug(
            f"[TECHDOCS]Setting requests session parameter 'timeout' "
            f"with value '{self._session_configuration.request_timeout}'"
        )

        retry_strategy = Retry(
            total=self._session_configuration.retry_count,
            backoff_factor=1,
            status_forcelist=[400, 429, 500, 502, 503, 504],
        )

        transport_adapter = _RequestsTimeoutAdapter(
            timeout=self._session_configuration.request_timeout,
            max_retries=retry_strategy,
        )
        self._session.mount("https://", transport_adapter)
        self._session.mount("http://", transport_adapter)

        config_dict = self._session_configuration.get_configuration_for_requests()
        for k, v in config_dict.items():
            if v is not None:
                logger.debug(
                    f"[TECHDOCS]Setting requests session parameter '{k}' with value '{v}'"
                )
        set_session_kwargs(self._session, config_dict)
        logger.info("[TECHDOCS]Base session created")

    def _validate_builder(self) -> None:
        if not self._configured:
            raise ValueError("No authentication yet configured")

    def connect(self) -> ApiClient:
        """Finalizes the API client and returns it for use.

        Authentication must be configured for this method to succeed.

        Raises
        ------
        ValueError
            When the client is not fully configured.
        """
        self._validate_builder()
        return ApiClient(self._session, self._api_url, self._session_configuration)

    def with_anonymous(self: Api_Client_Factory) -> Api_Client_Factory:
        """Set up the client authentication for anonymous use. This does not configure any authentication or
        authorization headers, users must provide any authentication information required themselves.

        Clients relying on custom authentication such as client certificates, or non-standard tokens should use this
        method.
        """
        if self.__test_connection():
            logger.info("[TECHDOCS]Connection success")
            self._configured = True
            return self
        assert False, "[TECHDOCS]Connection failures will throw above"

    def with_credentials(
        self: Api_Client_Factory, username: str, password: str, domain: str = None
    ) -> Api_Client_Factory:
        """Set up the client authentication for use with provided credentials.

        This method will attempt to connect to the API and use the provided WWW-Authenticate header to determine whether
        Negotiate, NTLM, or Basic Authentication should be used. The selected authentication method will then be
        configured for use.

        Notes
        -----
        NTLM authentication is not currently supported on Linux.

        Parameters
        ----------
        username : str
            Username for connection.
        password : str
            Password for connection.
        domain : Optional[str]
            Domain to use for connection if required.
        """
        logger.info(f"[TECHDOCS]Setting credentials for user '{username}")
        if domain is not None:
            username = f"{domain}\\{username}"
            logger.debug(
                f"[TECHDOCS]Setting domain for username, connecting as '{username}'"
            )

        initial_response = self._session.get(self._api_url)
        if self.__handle_initial_response(initial_response):
            return self
        headers = self.__get_authenticate_header(initial_response)
        logger.debug(
            "[TECHDOCS]Detected authentication methods: "
            + ", ".join([method for method in headers.keys()])
        )
        if "Negotiate" in headers or "NTLM" in headers:
            if _platform_windows:
                logger.debug(
                    "[TECHDOCS]Attempting to connect with NTLM authentication..."
                )
                self._session.auth = HttpNtlmAuth(username, password)
                if self.__test_connection():
                    logger.info("[TECHDOCS]Connection success")
                    self._configured = True
                    return self
        if "Basic" in headers:
            logger.debug("[TECHDOCS]Attempting connection with Basic authentication...")
            self._session.auth = HTTPBasicAuth(username, password)
            if self.__test_connection():
                logger.info("[TECHDOCS]Connection success")
                self._configured = True
                return self
        raise ConnectionError("[TECHDOCS]Unable to connect with credentials.")

    def with_autologon(self: Api_Client_Factory) -> Api_Client_Factory:
        """Set up the client authentication for use with Kerberos (also known as integrated windows authentication).

        Notes
        -----
        Requires the user to have a valid Kerberos Ticket-Granting-Ticket (TGT).

        On Windows this is provided by default.

        On Linux this requires the `[linux-kerberos]` extension to be installed, and your Kerberos installation
        must be configured manually. See `here <https://github.com/requests/requests-kerberos>`_ for more
        information on how to configure your Kerberos installation.
        """
        if not (_platform_windows or _linux_kerberos_enabled):
            raise ImportError(
                "[TECHDOCS]Kerberos is not enabled, to use it run `pip install openapi-client-common[linux-kerberos]`"
            )
        initial_response = self._session.get(self._api_url)
        if self.__handle_initial_response(initial_response):
            return self
        headers = self.__get_authenticate_header(initial_response)
        logger.debug(
            "[TECHDOCS]Detected authentication methods: "
            + ", ".join([method for method in headers.keys()])
        )
        if "Negotiate" in headers:
            logger.debug(
                f"[TECHDOCS]Using {NegotiateAuth.__qualname__} as a Negotiate backend."
            )
            logger.debug(
                "[TECHDOCS]Attempting connection with Negotiate authentication..."
            )
            self._session.auth = NegotiateAuth()
            if self.__test_connection():
                logger.info("[TECHDOCS]Connection success")
                self._configured = True
                return self
        raise ConnectionError("[TECHDOCS]Unable to connect with autologon.")

    def with_oidc(
        self,
        idp_session_configuration: SessionConfiguration = None,
    ) -> "OIDCSessionBuilder":
        """Set up the client authentication for use with OpenID Connect.

        Parameters
        ----------
        idp_session_configuration : Optional[SessionConfiguration]
            Additional configuration settings for the requests Session when connected to the OpenID Identity Provider.

        Notes
        -----
        OIDC Authentication requires the `[oidc]` extra to be installed.
        """
        if not _oidc_enabled:
            raise ImportError(
                "[TECHDOCS]OIDC features are not enabled, to use them run `pip install openapi-client-common[oidc]`"
            )
        initial_response = self._session.get(self._api_url)
        if self.__handle_initial_response(initial_response):
            return OIDCSessionBuilder(self)

        session_factory = OIDCSessionFactory(
            self._session,
            initial_response,
            self._session_configuration,
            idp_session_configuration,
        )

        return OIDCSessionBuilder(self, session_factory)

    def __test_connection(self) -> bool:
        """[TECHDOCS]Method attempts to connect to API server, if this returns a 2XX status code the method returns
        True, else the method will throw a :obj:`APIConnectionError` with the status code and the reason phrase. If the
        underlying requests method returns an exception of its own it is left to propagate as-is (for example a
        :obj:`~requests.exceptions.SSLException` if the remote certificate is untrusted).

        Raises
        ------
        APIConnectionError
            If the API server returns a status code other than 2XX.
        """
        resp = self._session.get(self._api_url)
        if 200 <= resp.status_code < 300:
            return True
        else:
            raise ApiConnectionException(resp.status_code, resp.reason, resp.text)

    def __handle_initial_response(
        self, initial_response: requests.Response
    ) -> "Optional[ApiClientFactory]":
        """[TECHDOCS]Verifies that an initial 401 is returned if we expect to require authentication. If a 2XX response
        is returned then all is well, but we will not use any authentication in future. Otherwise something else has
        gone awry: return an :obj:`ApiConnectionException` with information about the response.

        Parameters
        ----------
        initial_response : requests.Response
            Response from querying the API server

        Raises
        ------
        ApiConnectionError
            If the API server returns a status code other than 2XX or 401

        Warns
        -----
        AuthenticationWarning
            If the connection succeeds when the user's requested authentication suggests it should fail.
        """
        if 200 <= initial_response.status_code < 300:
            warnings.warn(
                AuthenticationWarning(
                    "[TECHDOCS]Credentials were provided but server accepts anonymous "
                    "connections. Continuing without credentials."
                )
            )
            logger.info("[TECHDOCS]Connection success")
            self._configured = True
            return self
        elif initial_response.status_code != 401:
            raise ApiConnectionException(
                initial_response.status_code,
                initial_response.reason,
                initial_response.text,
            )
        else:
            return None

    @staticmethod
    def __get_authenticate_header(
        response: requests.Response,
    ) -> "CaseInsensitiveOrderedDict":
        """Helper method to extract the www-authenticate header from a requests response.

        Parameters
        ----------
        response : requests.Response
            Raw response from the API server.

        Raises
        ------
        ValueError
            If the response contains no www-authenticate header to be parsed.
        """
        if "www-authenticate" not in response.headers:
            raise ValueError(
                "[TECHDOCS]No www-authenticate header was provided, cannot continue..."
            )
        return parse_authenticate(response.headers["www-authenticate"])


class OIDCSessionBuilder:
    def __init__(
        self,
        client_factory: ApiClientFactory,
        session_factory: "Optional[OIDCSessionFactory]" = None,
    ) -> None:
        """Class to help create OIDC sessions from different types of input, provides OIDC specific configuration
        options.

        Parameters
        ----------
        client_factory : ApiClientFactory
            Parent API client factory object that will be returned once configuration is complete
        session_factory : Optional[OIDCSessionFactory]
            OIDC session factory object that will be configured and used to return an OAuth supporting Session
        """
        self._client_factory = client_factory
        self._session_factory = session_factory

    def with_stored_token(
        self, token_name: str = "ansys-openapi-common-oidc"
    ) -> ApiClientFactory:
        """Use a token stored in the system keyring to authenticate the session. This method requires a correctly
        configured system keyring backend.

        Parameters
        ----------
        token_name : str
            Name of the token key in the system keyring

        Raises
        ------
        ValueError
            If no token is found in the system keyring with the provided token_name
        """
        if self._session_factory is None:
            return self._client_factory
        refresh_token = keyring.get_password(token_name, self._client_factory._api_url)
        if refresh_token is None:
            raise ValueError("No stored credentials found.")

        return self.with_token(refresh_token=refresh_token)

    def with_token(
        self, refresh_token: str, access_token: Optional[str] = None
    ) -> ApiClientFactory:
        """Use a provided access token or refresh token to authenticate the session.

        If access token is provided then it will be used immediately, when it expires the token will
        be refreshed. If no access token is provided then the refresh token will be used immediately to fetch an
        access token.

        Parameters
        ----------
        refresh_token : str
            Refresh token
        access_token : str
            Access token
        """
        if self._session_factory is None:
            return self._client_factory
        self._client_factory._session = (
            self._session_factory.get_session_with_provided_token(
                access_token=access_token, refresh_token=refresh_token
            )
        )
        self._client_factory._configured = True
        return self._client_factory

    def authorize(self, login_timeout: int = 60) -> ApiClientFactory:
        """Authenticate the user interactively, open a web browser and wait for the user to log in.

        Parameters
        ----------
        login_timeout : int
            Time in seconds to wait for the user to authenticate in their web browser
        """
        if self._session_factory is None:
            return self._client_factory
        self._client_factory._session = (
            self._session_factory.get_session_with_interactive_authorization(
                login_timeout
            )
        )
        self._client_factory._configured = True
        return self._client_factory


class _RequestsTimeoutAdapter(HTTPAdapter):
    """Requests transport adapter to provide a default timeout for all requests sent to the API Server

    Attributes
    ----------
    timeout : int
        Time in seconds to wait for a response from the API server (default 31s).
    """

    timeout: int = 31

    def __init__(self, *args, **kwargs):
        if "timeout" in kwargs:
            self.timeout = kwargs["timeout"]
            del kwargs["timeout"]
        super().__init__(*args, **kwargs)

    def send(
        self,
        request: requests.PreparedRequest,
        stream: bool = False,
        timeout: Union[None, float, Tuple[float, float], Tuple[float, None]] = None,
        verify: Union[bool, str] = True,
        cert: Union[None, bytes, str, Container[Union[bytes, str]]] = None,
        proxies: Optional[Mapping[str, str]] = None,
    ) -> requests.Response:
        """Method called when sending a request to the API

        If no timeout is specified on the request then it is set to the provided value.

        Parameters
        ----------
        request : requests.PreparedRequest
            Request to the API
        stream : bool
            Whether to stream the request content.
        timeout : Union[None, float, Tuple[float, float], Tuple[float, None]]
            How long to wait for the server to send data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        verify : Union[bool, str]
            Either a boolean, in which case it controls whether we verify the server's TLS certificate, or a string, in
            which case it must be a path to a CA bundle to use.
        cert : Union[None, bytes, str, Container[Union[bytes, str]]]
            User provided client certificate to send with the request, optionally with password.
        proxies : Optional[Mapping[str, str]]
            The proxies dictionary to apply to the request.
        """
        if timeout is None:
            timeout = self.timeout
        return super().send(request, stream, timeout, verify, cert, proxies)
